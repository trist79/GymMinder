package edu.temple.gymminder;

import java.util.ArrayList;
import java.util.Arrays;

import weka.classifiers.functions.Logistic;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instances;

/**
 * Created by nickdellosa on 4/26/17.
 */

public class ClassifierCoefficients {

    private static final Attribute DST;
    private static final Attribute MIN;
    private static final Attribute MAX;
    private static final Attribute SD;
    private static final Attribute RMS;
    private static final Attribute DUR;
    private static final Attribute VALID;
    private static final ArrayList<Attribute> ATTRIBUTES;

    public final double coefpure;
    public final double coefdst;
    public final double coefmin;
    public final double coefmax;
    public final double coefsd;
    public final double coefrms;
    public final double coefdur;

    public static final int NUMCOEFFICIENTS;

    private static final String POSITIVE, NEGATIVE;

    static {
        NUMCOEFFICIENTS = 7;
        POSITIVE = "pos";
        NEGATIVE = "neg";
        VALID = new Attribute("valid", Arrays.asList(POSITIVE, NEGATIVE));
        DST = new Attribute("dst");
        MIN = new Attribute("min");
        MAX = new Attribute("max");
        SD = new Attribute("sd");
        RMS = new Attribute("rms");
        DUR = new Attribute("dur");
        ATTRIBUTES = new ArrayList<>(Arrays.asList(VALID, DST, MIN, MAX, SD, RMS, DUR));
    }

    public ClassifierCoefficients(double coefpure, double coefdst, double coefmin, double coefmax, double coefsd, double coefrms, double coefdur) {
        this.coefpure = coefpure;
        this.coefdst = coefdst;
        this.coefmin = coefmin;
        this.coefmax = coefmax;
        this.coefsd = coefsd;
        this.coefrms = coefrms;
        this.coefdur = coefdur;
    }

    public ClassifierCoefficients(double[] coefs) {
        this(coefs[0], coefs[1], coefs[2], coefs[3], coefs[4], coefs[5], coefs[6]);
    }

    /**
     * Returns the coefficient generated by the classifier at each particular index.
     *
     * @param index the index of the coefficient to return
     * @return the coefficient at index
     */
    public double getCoefficientAtIndex(int index) {
        switch (index) {
            case 0:
                return coefpure;
            case 1:
                return coefdst;
            case 2:
                return coefmin;
            case 3:
                return coefmax;
            case 4:
                return coefsd;
            case 5:
                return coefrms;
            case 6:
                return coefdur;
            default:
                throw new RuntimeException("Attribute at index " + index + " does not exist.");
        }
    }

    /**
     * Generates the coefficients for false-positive detection based on a logistic regression classifier trained using calibration data.
     *
     * @param goodBounds The bounds of good repetitions.
     * @param badBounds  The bounds of false-positive repetitions.
     * @return The coefficients generated by the logistic regression.
     */
    public static ClassifierCoefficients generateCoefficients(ArrayList<DataUtils.DetectedBounds> goodBounds, ArrayList<DataUtils.DetectedBounds> badBounds) {
        Instances ii = new Instances("calibrate", ATTRIBUTES, goodBounds.size() + badBounds.size());
        ii.setClass(VALID);
        for (DataUtils.DetectedBounds db : goodBounds) {
            DenseInstance i = new DenseInstance(NUMCOEFFICIENTS);
            i.setDataset(ii);
            double[] bounds = db.getAsArray();
            for (int j=0; j < ATTRIBUTES.size()-1; j++) {
                i.setValue(ATTRIBUTES.get(j+1), bounds[j]);
            }
            i.setClassValue(POSITIVE);
            ii.add(i);
        }
        for (DataUtils.DetectedBounds db : badBounds) {
            DenseInstance i = new DenseInstance(NUMCOEFFICIENTS);
            i.setDataset(ii);
            double[] bounds = db.getAsArray();
            for (int j=0; j < ATTRIBUTES.size()-1; j++) {
                i.setValue(ATTRIBUTES.get(j+1), bounds[j]);
            }
            i.setClassValue(NEGATIVE);
            ii.add(i);
        }
        Logistic lr = new Logistic();
        try {
            lr.buildClassifier(ii);
            double[][] coefs = lr.coefficients();
            double[] cc = new double[NUMCOEFFICIENTS];
            cc[0] = lr.getRidge();
            for (int i=0; i < coefs.length; i++) {
                cc[i+1] = coefs[i][0];
            }
            return new ClassifierCoefficients(cc);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static double getAttributeValue(DataUtils.DetectedBounds bounds, int index) {
        switch (index) {
            case 1:
                return bounds.dst;
            case 2:
                return bounds.min;
            case 3:
                return bounds.max;
            case 4:
                return bounds.sd;
            case 5:
                return bounds.rms;
            case 6:
                return bounds.dur;
            default:
                throw new RuntimeException("Attribute at index " + index + " does not exist.");
        }
    }

    public static class Builder {

        ArrayList<DataUtils.DetectedBounds> goodBounds;
        ArrayList<DataUtils.DetectedBounds> badBounds;

        public Builder() {
            this.goodBounds = new ArrayList<>();
            this.badBounds = new ArrayList<>();
        }

        public void addGoodBounds(DataUtils.DetectedBounds bounds) {
            goodBounds.add(bounds);
        }

        public void addBadBounds(DataUtils.DetectedBounds bounds) {
            badBounds.add(bounds);
        }

        public ClassifierCoefficients build() {
            if (goodBounds.size() > 1 && badBounds.size() > 1) {
                return ClassifierCoefficients.generateCoefficients(goodBounds, badBounds);
            } else {
                return null;
            }
        }
    }
}
